<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Satellite POV Earth Wallpaper</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000;
        font-family: "Segoe UI", system-ui, sans-serif;
        color: #dbe9ff;
      }

      #overlay {
        position: fixed;
        top: 12px;
        left: 12px;
        padding: 10px 12px;
        background: rgba(0, 0, 0, 0.55);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 6px;
        max-width: min(480px, 80vw);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
        backdrop-filter: blur(6px);
      }

      #overlay h1 {
        margin: 0 0 6px;
        font-size: 16px;
        letter-spacing: 0.4px;
      }

      #overlay p {
        margin: 4px 0;
        font-size: 13px;
        line-height: 1.4;
      }

      #overlay code {
        font-size: 12px;
        background: rgba(255, 255, 255, 0.08);
        padding: 2px 4px;
        border-radius: 4px;
      }

      #sat-label {
        position: fixed;
        transform: translate(-50%, -50%);
        display: flex;
        align-items: center;
        gap: 6px;
        pointer-events: none;
        color: #f4f7ff;
        font-size: 16px;
        font-weight: 600;
        text-shadow: 0 0 4px rgba(0, 0, 0, 0.9);
        z-index: 11;
      }

      #sat-label .icon {
        font-size: 24px; /* size of the satellite emoji */
      }

      #sat-label .name {
        letter-spacing: 0.06em;
      }

      #vignette {
        position: fixed;
        inset: 0;
        pointer-events: none;
        background: radial-gradient(
          circle at center,
          rgba(0, 0, 0, 0) 40%,
          rgba(0, 0, 0, 0.8) 100%
        );
        z-index: 2;
      }

    </style>
  </head>
  <body>
    <div id="overlay">
      <h1>Live satellite POV</h1>
      <p>
        Update the TLE below with your target spacecraft (e.g. 6GSTARLAB), save, and
        reload in your live-wallpaper app. Time is read from your clock, so the view
        follows the orbit in real time.
      </p>
      <p>
        Current TLE:
        <br />
        <code id="tle-1"></code>
        <br />
        <code id="tle-2"></code>
      </p>
    </div>

    <div id="sat-label">
      <span class="icon">ðŸ›°</span>
      <span class="name">6GSTARLAB</span>
    </div>
    <div id="vignette"></div>

    <!-- three.js (global THREE object) -->
    <script src="./three.min.js"></script>
    <!-- satellite.js for TLE propagation -->
    <script src="./satellite.min.js"></script>

    <script>
      // --- TLE for your satellite (can be changed later) ---
      const tleLine1 =
        "1 98500U 14900A   25330.80204314  .00000000  00000-0 -98474-3 0    00";
      const tleLine2 =
        "2 98500  97.4398  36.4670 0001310  63.2710 283.1296 15.17672202    08";

      // Show TLE in overlay
      document.getElementById("tle-1").textContent = tleLine1;
      document.getElementById("tle-2").textContent = tleLine2;

      // Parse TLE with satellite.js
      const satrec = window.satellite.twoline2satrec(tleLine1, tleLine2);

      // --- THREE.js scene setup ---
      const scene = new THREE.Scene();

      const orbitLineMaterial = new THREE.LineBasicMaterial({
        color: 0x6fb6ff,
        linewidth: 1,
      });

      const orbitLineGeometry = new THREE.BufferGeometry();
      const orbitSamples = 256; // number of points along the orbit

      // allocate buffer once
      const orbitPositions = new Float32Array(orbitSamples * 3);
      orbitLineGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(orbitPositions, 3)
      );

      const orbitLine = new THREE.Line(orbitLineGeometry, orbitLineMaterial);
      scene.add(orbitLine);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;

      // Narrower FOV for a nice SpaceX-like framing
      const camera = new THREE.PerspectiveCamera(
        35,
        window.innerWidth / window.innerHeight,
        1,
        300000
      );

      // Lights
      const ambient = new THREE.AmbientLight(0x223344, 0.8);
      const sunlight = new THREE.DirectionalLight(0xffffff, 1.2);
      sunlight.position.set(15000, 8000, 12000);
      scene.add(ambient, sunlight);

      // --- Earth ---
      const earthRadiusKm = 6371;
      const earthGeometry = new THREE.SphereGeometry(earthRadiusKm, 96, 96);
      const earthTexture = new THREE.TextureLoader().load("earth.jpg");
      earthTexture.colorSpace = THREE.SRGBColorSpace;

      const earthMaterial = new THREE.MeshPhongMaterial({
        map: earthTexture,
        color: 0x9fc4ff,
        shininess: 18,
        specular: 0x222222,
      });

      const earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
      scene.add(earthMesh);

      // Soft atmospheric glow
      const glowGeometry = new THREE.SphereGeometry(earthRadiusKm * 1.02, 64, 64);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0x6fbfff,
        transparent: true,
        opacity: 0.16,
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      scene.add(glow);

      // --- Starfield background (approximate, not real constellations) ---
      const starRadius = earthRadiusKm * 22;
      const starsGeometry = new THREE.BufferGeometry();
      const starVertices = [];
      const starCount = 4000;

      for (let i = 0; i < starCount; i++) {
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = starRadius;

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        starVertices.push(x, y, z);
      }

      starsGeometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(starVertices, 3)
      );

      const starsMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 80,
        sizeAttenuation: true,
        transparent: true,
        opacity: 0.85,
        depthWrite: false,
      });

      const starField = new THREE.Points(starsGeometry, starsMaterial);
      scene.add(starField);

      // --- Satellite marker (small glowing sphere) ---
      const satMarkerGeometry = new THREE.SphereGeometry(80, 16, 16);
      const satMarkerMaterial = new THREE.MeshBasicMaterial({
        color: 0xffe066,
      });
      const satMarker = new THREE.Mesh(satMarkerGeometry, satMarkerMaterial);
      satMarker.visible = false;
      scene.add(satMarker);

      // 2D label element
      const satLabelEl = document.getElementById("sat-label");

      // --- Conversion: TLE -> ECF position at given date ---
      let lastSafePosition = new THREE.Vector3(0, 0, earthRadiusKm + 500);

      function propagateToEcf(date) {
        const pv = window.satellite.propagate(
          satrec,
          date.getUTCFullYear(),
          date.getUTCMonth() + 1,
          date.getUTCDate(),
          date.getUTCHours(),
          date.getUTCMinutes(),
          date.getUTCSeconds()
        );

        if (!pv.position) {
          return lastSafePosition.clone();
        }

        const gmst = window.satellite.gstime(date);
        const ecf = window.satellite.eciToEcf(pv.position, gmst);

        const pos = new THREE.Vector3(ecf.x, ecf.y, ecf.z);

        // Clamp slightly above surface to avoid clipping
        const distance = pos.length();
        const minDistance = earthRadiusKm + 120;
        if (distance < minDistance) {
          pos.setLength(minDistance);
        }

        lastSafePosition = pos.clone();
        return pos;
      }

      // Rebuild the orbit line around "now"
      function rebuildOrbitLine() {
        const now = new Date();
        const orbitPeriodMinutes = 95; // approximate LEO period; good enough visually

        for (let i = 0; i < orbitSamples; i++) {
          const tMinutes = (i / (orbitSamples - 1)) * orbitPeriodMinutes;
          const t = new Date(now.getTime() + tMinutes * 60 * 1000);
          const p = propagateToEcf(t);

          const idx = i * 3;
          orbitPositions[idx + 0] = p.x;
          orbitPositions[idx + 1] = p.y;
          orbitPositions[idx + 2] = p.z;
        }

        orbitLineGeometry.attributes.position.needsUpdate = true;
      }

      let smoothedSatPos = new THREE.Vector3();
      let firstFrame = true;
      const cameraDistance = earthRadiusKm * 3.5; // tweak 2.5â€“3.5 for taste

      // initial build
      rebuildOrbitLine();

      // update every minute so the orbit stays in sync
      setInterval(rebuildOrbitLine, 60 * 1000);


      // --- Animation loop ---
      function animate() {
        requestAnimationFrame(animate);

        const now = new Date();
        const satPos = propagateToEcf(now);

        if (firstFrame) {
          smoothedSatPos.copy(satPos);
          firstFrame = false;
        } else {
          // Lerp towards the true position for smooth motion
          const smoothingFactor = 0.01; // 0.05 = very smooth, 0.3 = snappier
          smoothedSatPos.lerp(satPos, smoothingFactor);
        }

        // Move the (hidden) marker so we still have a 3D point in the scene
        satMarker.position.copy(smoothedSatPos);

        // Camera: stay on same radial line as satellite, but further out
        // Camera stays on same radial line, but further out
        const dir = smoothedSatPos.clone().normalize();
        camera.position.copy(dir.multiplyScalar(cameraDistance));
        camera.up.set(0, 0, 1);
        camera.lookAt(0, 0, 0); // always look at Earth center

        // Project smoothed position to 2D for the icon+label
        const projected = smoothedSatPos.clone().project(camera);
        const x = (projected.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-projected.y * 0.5 + 0.5) * window.innerHeight;

        if (projected.z < 1) {
          satLabelEl.style.display = "flex";
          satLabelEl.style.left = `${x}px`;
          satLabelEl.style.top = `${y}px`;
        } else {
          // behind the camera
          satLabelEl.style.display = "none";
        }

        renderer.render(scene, camera);
      }

      animate();

      // --- Handle resize ---
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
